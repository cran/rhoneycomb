---
title: "rhoneycomb_documentation"
output:
  rmarkdown::html_vignette:
    fig_width: 7.1 
    fig_height: 6
vignette: >
  %\VignetteIndexEntry{rhoneycomb_documentation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(error = Sys.getenv("IN_PKGDOWN") != "true" || (getRversion() < "3.5"))
```

```{r setup , echo=FALSE}
library(rhoneycomb)
```

## A short guide to using the package "rhoneycomb"

The package “rhoneycomb” is a useful statistical 
tool for the construction and analysis of honeycomb selection designs.

## Installation and usage 
This section shows the installation of the package and the usage of underlying 
functions.  

### Installation
To install the package from CRAN, and then load it, use the following commands:


```{r setup, eval=FALSE,warning=FALSE , message=FALSE}
install.packages("rhoneycomb")
library(rhoneycomb)
```
### Example: Generate available Honeycomb Selection Designs
As a first step in the analysis, the plant breeder should check if any designs
are available for the number of under-evaluation entries. We do so by using the following 
command which returns a data frame containing the available designs. 
Here we run the function with a vector that contains numbers 1 to 60:

```{r}
generate(1:60)
```


## Example: Analysis of Experimental Data.
After obtaining the necessary design information from the function generate(), the user inputs the number of entries, the k parameter, the
number of rows, the number of plants per row and the planting distance into
the function HSD(). 
 


## Honeycomb Selection Design 
### Initialization 
We initialize the honeycomb selection design using the HSD command. Here:

* 7 corresponds to the number of entries
* 2 is the value of k parameter
* 10 is the number of rows
* 10 is the number of plants per row
* 1 is the interplant distance in meters 

```{r}
main_data<-HSD(7,2,10,10,1)

head(main_data,25) #Use the head function to get the top 25 rows.
```

 
### Ring Analysis 
After this step, we pass the response variable to the "Data"   column of the data frame generated by one of the
functions HSD, HSD0, HSD01 or HSD03. 
```{r}

main_data$Data<-wheat_data$main_spike_weight
result<-analysis(main_data,"Data",6)

head(result[[1]],10) #Use the head function to get the top 10 rows.
result[[2]] 
```

### Blocks Analysis 
By using the arguments blocks=TRUE in the analysis function, the data is being 
analyzed using complete moving replicate. If we also use the arguments “row_element” 
and “plant_element”, the plants included in the specific block are displayed.

```{r}
result<-analysis(main_data,"Data",blocks=TRUE,row_element=5,plant_element=5)
head(result[[1]],10) #Use the head function to get the top 10 rows.
result[[2]] 
```

## Honeycomb Selection Design with one entry

### Initialization 

Since there is no control entry in HSD0 design, we must only provide number of 
rows, number of plants and interplant distance to the function. Here:

* 10 is the number of rows
* 10 is the number of plants per row
* 1 is the interplant distance in meters 

```{r}
main_data<-HSD0(10,10,1)
main_data$Data<-wheat_data$main_spike_weight
head(main_data,10) #Use the head function to get the top 10 rows.
```

For the HSD01 design we must also add the value of K as first argument in the 
function:

```{r}
main_data<-HSD01(7,10,10,1)
main_data$Data<-wheat_data$main_spike_weight

head(main_data,10) #Use the head function to get the top 10 rows.
```
### Analysis
The analysis function returns only one data  frame.
```{r}
result<-analysis(main_data,"Data")
head(result[[1]],10) #Use the head function to get the top 10 rows.
```